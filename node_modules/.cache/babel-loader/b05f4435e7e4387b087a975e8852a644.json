{"ast":null,"code":"import { makePromiseBuffer, forEachEnvelopeItem, envelopeItemTypeToDataCategory, isRateLimited, resolvedSyncPromise, createEnvelope, serializeEnvelope, logger, updateRateLimits, SentryError } from '@sentry/utils';\nvar DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\n\nfunction createTransport(options, makeRequest) {\n  let buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);\n  let rateLimits = {};\n\n  var flush = timeout => buffer.drain(timeout);\n\n  function send(envelope) {\n    var filteredEnvelopeItems = []; // Drop rate limited items from envelope\n\n    forEachEnvelopeItem(envelope, (item, type) => {\n      var envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);\n\n      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    }); // Skip sending if envelope is empty after filtering out rate limited events\n\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise();\n    }\n\n    var filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems); // Creates client report for each item in an envelope\n\n    var recordEnvelopeLoss = reason => {\n      forEachEnvelopeItem(filteredEnvelope, (_, type) => {\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));\n      });\n    };\n\n    var requestTask = () => makeRequest({\n      body: serializeEnvelope(filteredEnvelope, options.textEncoder)\n    }).then(response => {\n      // We don't want to throw on NOK responses, but we want to at least log them\n      if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n      }\n\n      rateLimits = updateRateLimits(rateLimits, response);\n    }, error => {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Failed while sending event:', error);\n      recordEnvelopeLoss('network_error');\n    });\n\n    return buffer.add(requestTask).then(result => result, error => {\n      if (error instanceof SentryError) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Skipped sending event due to full buffer');\n        recordEnvelopeLoss('queue_overflow');\n        return resolvedSyncPromise();\n      } else {\n        throw error;\n      }\n    });\n  }\n\n  return {\n    send,\n    flush\n  };\n}\n\nexport { DEFAULT_TRANSPORT_BUFFER_SIZE, createTransport }; //# sourceMappingURL=base.js.map","map":null,"metadata":{},"sourceType":"module"}