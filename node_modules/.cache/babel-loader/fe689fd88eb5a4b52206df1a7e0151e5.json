{"ast":null,"code":"import { getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, isString, isPrimitive, isErrorEvent, getLocationHref, logger, addExceptionMechanism } from '@sentry/utils';\nimport { eventFromUnknownInput } from '../eventbuilder.js';\nimport { shouldIgnoreOnError } from '../helpers.js';\n/** Global handlers */\n\nclass GlobalHandlers {\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'GlobalHandlers';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  __init() {\n    this.name = GlobalHandlers.id;\n  }\n  /** JSDoc */\n\n  /**\n   * Stores references functions to installing handlers. Will set to undefined\n   * after they have been run so that they are not used twice.\n   */\n\n\n  __init2() {\n    this._installFunc = {\n      onerror: _installGlobalOnErrorHandler,\n      onunhandledrejection: _installGlobalOnUnhandledRejectionHandler\n    };\n  }\n  /** JSDoc */\n\n\n  constructor(options) {\n    ;\n\n    GlobalHandlers.prototype.__init.call(this);\n\n    GlobalHandlers.prototype.__init2.call(this);\n\n    this._options = {\n      onerror: true,\n      onunhandledrejection: true,\n      ...options\n    };\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  setupOnce() {\n    Error.stackTraceLimit = 50;\n    var options = this._options; // We can disable guard-for-in as we construct the options object above + do checks against\n    // `this._installFunc` for the property.\n\n    for (var key in options) {\n      var installFunc = this._installFunc[key];\n\n      if (installFunc && options[key]) {\n        globalHandlerLog(key);\n        installFunc();\n        this._installFunc[key] = undefined;\n      }\n    }\n  }\n\n}\n\nGlobalHandlers.__initStatic();\n/** JSDoc */\n\n\nfunction _installGlobalOnErrorHandler() {\n  addInstrumentationHandler('error', data => {\n    const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n\n    if (!hub.getIntegration(GlobalHandlers)) {\n      return;\n    }\n\n    const {\n      msg,\n      url,\n      line,\n      column,\n      error\n    } = data;\n\n    if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {\n      return;\n    }\n\n    var event = error === undefined && isString(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false), url, line, column);\n    event.level = 'error';\n    addMechanismAndCapture(hub, error, event, 'onerror');\n  });\n}\n/** JSDoc */\n\n\nfunction _installGlobalOnUnhandledRejectionHandler() {\n  addInstrumentationHandler('unhandledrejection', e => {\n    const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n\n    if (!hub.getIntegration(GlobalHandlers)) {\n      return;\n    }\n\n    let error = e; // dig the object of the rejection out of known event types\n\n    try {\n      // PromiseRejectionEvents store the object of the rejection under 'reason'\n      // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n      if ('reason' in e) {\n        error = e.reason;\n      } // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents\n      // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into\n      // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec\n      // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and\n      // https://github.com/getsentry/sentry-javascript/issues/2380\n      else if ('detail' in e && 'reason' in e.detail) {\n        error = e.detail.reason;\n      }\n    } catch (_oO) {// no-empty\n    }\n\n    if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {\n      return true;\n    }\n\n    var event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);\n    event.level = 'error';\n    addMechanismAndCapture(hub, error, event, 'onunhandledrejection');\n    return;\n  });\n}\n/**\n * Create an event from a promise rejection where the `reason` is a primitive.\n *\n * @param reason: The `reason` property of the promise rejection\n * @returns An Event object with an appropriate `exception` value\n */\n\n\nfunction _eventFromRejectionWithPrimitive(reason) {\n  return {\n    exception: {\n      values: [{\n        type: 'UnhandledRejection',\n        // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n        value: `Non-Error promise rejection captured with value: ${String(reason)}`\n      }]\n    }\n  };\n}\n/**\n * This function creates a stack from an old, error-less onerror handler.\n */\n\n\nfunction _eventFromIncompleteOnError(msg, url, line, column) {\n  var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i; // If 'message' is ErrorEvent, get real message from inside\n\n  let message = isErrorEvent(msg) ? msg.message : msg;\n  let name = 'Error';\n  var groups = message.match(ERROR_TYPES_RE);\n\n  if (groups) {\n    name = groups[1];\n    message = groups[2];\n  }\n\n  var event = {\n    exception: {\n      values: [{\n        type: name,\n        value: message\n      }]\n    }\n  };\n  return _enhanceEventWithInitialFrame(event, url, line, column);\n}\n/** JSDoc */\n\n\nfunction _enhanceEventWithInitialFrame(event, url, line, column) {\n  // event.exception\n  var e = event.exception = event.exception || {}; // event.exception.values\n\n  var ev = e.values = e.values || []; // event.exception.values[0]\n\n  var ev0 = ev[0] = ev[0] || {}; // event.exception.values[0].stacktrace\n\n  var ev0s = ev0.stacktrace = ev0.stacktrace || {}; // event.exception.values[0].stacktrace.frames\n\n  var ev0sf = ev0s.frames = ev0s.frames || [];\n  var colno = isNaN(parseInt(column, 10)) ? undefined : column;\n  var lineno = isNaN(parseInt(line, 10)) ? undefined : line;\n  var filename = isString(url) && url.length > 0 ? url : getLocationHref(); // event.exception.values[0].stacktrace.frames\n\n  if (ev0sf.length === 0) {\n    ev0sf.push({\n      colno,\n      filename,\n      function: '?',\n      in_app: true,\n      lineno\n    });\n  }\n\n  return event;\n}\n\nfunction globalHandlerLog(type) {\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Global Handler attached: ${type}`);\n}\n\nfunction addMechanismAndCapture(hub, error, event, type) {\n  addExceptionMechanism(event, {\n    handled: false,\n    type\n  });\n  hub.captureEvent(event, {\n    originalException: error\n  });\n}\n\nfunction getHubAndOptions() {\n  var hub = getCurrentHub();\n  var client = hub.getClient();\n  var options = client && client.getOptions() || {\n    stackParser: () => [],\n    attachStacktrace: false\n  };\n  return [hub, options.stackParser, options.attachStacktrace];\n}\n\nexport { GlobalHandlers }; //# sourceMappingURL=globalhandlers.js.map","map":null,"metadata":{},"sourceType":"module"}