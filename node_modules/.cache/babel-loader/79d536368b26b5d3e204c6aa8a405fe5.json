{"ast":null,"code":"import { dropUndefinedKeys } from '@sentry/utils';\nimport { getCurrentHub } from './hub.js';\n/**\n * @inheritdoc\n */\n\nclass SessionFlusher {\n  __init() {\n    this.flushTimeout = 60;\n  }\n\n  __init2() {\n    this._pendingAggregates = {};\n  }\n\n  __init3() {\n    this._isEnabled = true;\n  }\n\n  constructor(client, attrs) {\n    ;\n\n    SessionFlusher.prototype.__init.call(this);\n\n    SessionFlusher.prototype.__init2.call(this);\n\n    SessionFlusher.prototype.__init3.call(this);\n\n    this._client = client; // Call to setInterval, so that flush is called every 60 seconds\n\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSession` */\n\n\n  flush() {\n    var sessionAggregates = this.getSessionAggregates();\n\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n\n    this._pendingAggregates = {};\n\n    this._client.sendSession(sessionAggregates);\n  }\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n\n\n  getSessionAggregates() {\n    var aggregates = Object.keys(this._pendingAggregates).map(key => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n    var sessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n  /** JSDoc */\n\n\n  close() {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n\n\n  incrementSessionStatusCount() {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    var scope = getCurrentHub().getScope();\n    var requestSession = scope && scope.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date()); // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n\n\n      if (scope) {\n        scope.setRequestSession(undefined);\n      }\n    }\n  }\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n\n\n  _incrementSessionStatusCount(status, date) {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    var sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {}; // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n\n    var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n\n}\n\nexport { SessionFlusher }; //# sourceMappingURL=sessionflusher.js.map","map":null,"metadata":{},"sourceType":"module"}