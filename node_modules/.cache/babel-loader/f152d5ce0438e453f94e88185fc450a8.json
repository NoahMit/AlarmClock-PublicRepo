{"ast":null,"code":"import { SentryError } from './error.js';\n/** Regular expression used to parse a Dsn. */\n\nvar DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+))?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol) {\n  return protocol === 'http' || protocol === 'https';\n}\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\n\n\nfunction dsnToString(dsn) {\n  let withPassword = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const {\n    host,\n    path,\n    pass,\n    port,\n    projectId,\n    protocol,\n    publicKey\n  } = dsn;\n  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` + `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`;\n}\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents\n */\n\n\nfunction dsnFromString(str) {\n  var match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    throw new SentryError(`Invalid Sentry Dsn: ${str}`);\n  }\n\n  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n  var split = projectId.split('/');\n\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop();\n  }\n\n  if (projectId) {\n    var projectMatch = projectId.match(/^\\d+/);\n\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({\n    host,\n    pass,\n    path,\n    projectId,\n    port,\n    protocol: protocol,\n    publicKey\n  });\n}\n\nfunction dsnFromComponents(components) {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId\n  };\n}\n\nfunction validateDsn(dsn) {\n  if (!(typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    return;\n  }\n\n  const {\n    port,\n    projectId,\n    protocol\n  } = dsn;\n  var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];\n  requiredComponents.forEach(component => {\n    if (!dsn[component]) {\n      throw new SentryError(`Invalid Sentry Dsn: ${component} missing`);\n    }\n  });\n\n  if (!projectId.match(/^\\d+$/)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n  }\n\n  if (!isValidProtocol(protocol)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);\n  }\n\n  return true;\n}\n/** The Sentry Dsn, identifying a Sentry instance and project. */\n\n\nfunction makeDsn(from) {\n  var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  validateDsn(components);\n  return components;\n}\n\nexport { dsnFromString, dsnToString, makeDsn }; //# sourceMappingURL=dsn.js.map","map":null,"metadata":{},"sourceType":"module"}